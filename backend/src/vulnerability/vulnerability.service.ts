import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { DatabaseService } from '../database/database.service';
import { VulnerabilityReport, ScanType, ScanStatus, Prisma } from '@prisma/client';
import { CreateScanDto, ScanQueryDto } from './dto/vulnerability.dto';

export interface ScanResult {
  vulnerability: {
    id: string;
    severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
    title: string;
    description: string;
    cvss?: number;
    cve?: string;
    solution?: string;
  };
  port?: number;
  service?: string;
  evidence?: string;
}

@Injectable()
export class VulnerabilityService {
  constructor(
    private readonly database: DatabaseService,
    @InjectQueue('vulnerability-scan') private scanQueue: Queue
  ) {}

  async createScan(createScanDto: CreateScanDto, userId: string, userRole: string): Promise<VulnerabilityReport> {
    const deviceWhere: Prisma.DeviceWhereInput = { id: createScanDto.deviceId };
    if (userRole !== 'ADMIN') {
      deviceWhere.ownerId = userId;
    }

    const device = await this.database.device.findFirst({
      where: deviceWhere
    });

    if (!device) {
      throw new NotFoundException('Device not found or access denied');
    }

    const scanReport = await this.database.vulnerabilityReport.create({
      data: {
        deviceId: createScanDto.deviceId,
        scanType: createScanDto.scanType,
        status: ScanStatus.PENDING,
      },
      include: {
        device: {
          select: {
            id: true,
            name: true,
            ipAddress: true,
            type: true,
          }
        }
      }
    });

    await this.scanQueue.add('perform-scan', {
      scanId: scanReport.id,
      deviceId: createScanDto.deviceId,
      scanType: createScanDto.scanType,
      deviceInfo: {
        ipAddress: device.ipAddress,
        name: device.name,
        type: device.type,
      }
    });

    return scanReport;
  }

  async findAll(query: ScanQueryDto, userId: string, userRole: string): Promise<VulnerabilityReport[]> {
    const where: Prisma.VulnerabilityReportWhereInput = {};

    if (query.deviceId || userRole !== 'ADMIN') {
      where.device = {};
      if (query.deviceId) where.device.id = query.deviceId;
      if (userRole !== 'ADMIN') where.device.ownerId = userId;
    }

    if (query.scanType) {
      where.scanType = query.scanType;
    }

    const limit = query.limit ? parseInt(query.limit, 10) : 50;

    return this.database.vulnerabilityReport.findMany({
      where,
      include: {
        device: {
          select: {
            id: true,
            name: true,
            ipAddress: true,
            type: true,
            owner: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                email: true,
              }
            }
          }
        }
      },
      orderBy: { startedAt: 'desc' },
      take: limit,
    });
  }

  async findOne(id: string, userId: string, userRole: string): Promise<VulnerabilityReport> {
    const where: Prisma.VulnerabilityReportWhereInput = { id };

    if (userRole !== 'ADMIN') {
      where.device = { ownerId: userId };
    }

    const scanReport = await this.database.vulnerabilityReport.findFirst({
      where,
      include: {
        device: {
          select: {
            id: true,
            name: true,
            ipAddress: true,
            type: true,
            owner: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                email: true,
              }
            }
          }
        }
      }
    });

    if (!scanReport) {
      throw new NotFoundException('Scan report not found or access denied');
    }

    return scanReport;
  }

  async updateScanStatus(scanId: string, status: ScanStatus, results?: any): Promise<VulnerabilityReport> {
    const updateData: any = { 
      status,
      ...(status === ScanStatus.COMPLETED && { completedAt: new Date() })
    };

    if (results) {
      updateData.findings = results;
      
      if (Array.isArray(results)) {
        updateData.criticalCount = results.filter(r => r.vulnerability?.severity === 'CRITICAL').length;
        updateData.highCount = results.filter(r => r.vulnerability?.severity === 'HIGH').length;
        updateData.mediumCount = results.filter(r => r.vulnerability?.severity === 'MEDIUM').length;
        updateData.lowCount = results.filter(r => r.vulnerability?.severity === 'LOW').length;
      }
    }

    return this.database.vulnerabilityReport.update({
      where: { id: scanId },
      data: updateData,
    });
  }

  async getDeviceScanHistory(deviceId: string, userId: string, userRole: string): Promise<VulnerabilityReport[]> {
    const deviceWhere: Prisma.DeviceWhereInput = { id: deviceId };
    if (userRole !== 'ADMIN') {
      deviceWhere.ownerId = userId;
    }

    const device = await this.database.device.findFirst({
      where: deviceWhere
    });

    if (!device) {
      throw new NotFoundException('Device not found or access denied');
    }

    return this.database.vulnerabilityReport.findMany({
      where: { deviceId },
      orderBy: { startedAt: 'desc' },
      take: 20,
    });
  }

  async getScanStatistics(userId: string, userRole: string): Promise<any> {
    const where: Prisma.VulnerabilityReportWhereInput = {};
    
    if (userRole !== 'ADMIN') {
      where.device = { ownerId: userId };
    }

    const [
      totalScans,
      completedScans,
      runningScans,
      failedScans,
      criticalVulns,
      highVulns,
      mediumVulns,
      lowVulns,
    ] = await Promise.all([
      this.database.vulnerabilityReport.count({ where }),
      this.database.vulnerabilityReport.count({ 
        where: { ...where, status: ScanStatus.COMPLETED }
      }),
      this.database.vulnerabilityReport.count({ 
        where: { ...where, status: ScanStatus.RUNNING }
      }),
      this.database.vulnerabilityReport.count({ 
        where: { ...where, status: ScanStatus.FAILED }
      }),
      this.database.vulnerabilityReport.aggregate({
        where: { ...where, status: ScanStatus.COMPLETED },
        _sum: { criticalCount: true }
      }),
      this.database.vulnerabilityReport.aggregate({
        where: { ...where, status: ScanStatus.COMPLETED },
        _sum: { highCount: true }
      }),
      this.database.vulnerabilityReport.aggregate({
        where: { ...where, status: ScanStatus.COMPLETED },
        _sum: { mediumCount: true }
      }),
      this.database.vulnerabilityReport.aggregate({
        where: { ...where, status: ScanStatus.COMPLETED },
        _sum: { lowCount: true }
      }),
    ]);

    return {
      totalScans,
      completedScans,
      runningScans,
      failedScans,
      vulnerabilities: {
        critical: criticalVulns._sum.criticalCount || 0,
        high: highVulns._sum.highCount || 0,
        medium: mediumVulns._sum.mediumCount || 0,
        low: lowVulns._sum.lowCount || 0,
      },
    };
  }

  async deleteScan(id: string, userId: string, userRole: string): Promise<void> {
    await this.findOne(id, userId, userRole);

    await this.database.vulnerabilityReport.delete({
      where: { id }
    });
  }

  async cancelScan(id: string, userId: string, userRole: string): Promise<VulnerabilityReport> {
    const scan = await this.findOne(id, userId, userRole);

    if (scan.status === ScanStatus.COMPLETED) {
      throw new Error('Cannot cancel completed scan');
    }

    if (scan.status === ScanStatus.PENDING) {
      const jobs = await this.scanQueue.getJobs(['waiting', 'delayed']);
      const job = jobs.find(j => j.data.scanId === id);
      if (job) {
        await job.remove();
      }
    }

    return this.updateScanStatus(id, ScanStatus.CANCELLED);
  }
}
